<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
<TITLE>string.h</TITLE>
<STYLE TYPE="TEXT/CSS">
<!--
.IE3-DUMMY { CONT-SIZE: 100%; }
BODY { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; BACKGROUND-COLOR: #E0E0E0; }
P { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; }
H1 { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; }
H2 { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; }
H3 { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; }
H4 { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; }
H5 { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; }
H6 { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; }
UL { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; }
TD { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; BACKGROUND-COLOR: #FFFFFF; }
.NOBORDER { BACKGROUND-COLOR: #E0E0E0; PADDING: 0pt; }
.NOBORDER TD { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; BACKGROUND-COLOR: #E0E0E0; PADDING: 0pt; }
.CODE { FONT-FAMILY: Courier New; }
-->
</STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#E0E0E0">
<FONT SIZE="5"><B>The &lt;string.h&gt; Header File</B></FONT>
<HR>
<P><B>ANSI-compatible string manipulation routines</B></P>

<H3><U>Functions</U></H3>
<DL INDENT="20"><DT><B><A HREF="mem.html#_memset">_memset</A></B><DD>Sets <I>num</I> bytes of <I>buffer</I> to byte <I>c</I>.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#CharNumber">CharNumber</A></B><DD>Writes an unsigned char in base 10 at given offset from the beginning of a string, and 
null-terminates the string.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#cmpstri">cmpstri</A></B><DD>Performs case-insensitive string comparison.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#FirstNonblank">FirstNonblank</A></B><DD>Returns a pointer to the first nonblank character in given string.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="mem.html#memchr">memchr</A></B><DD>Searches the first <I>len</I> bytes of array <I>str</I> for character <I>c</I>.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="mem.html#memcmp">memcmp</A></B><DD>Compares two blocks of signed chars.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="mem.html#memcpy">memcpy</A></B><DD>Copies a block of <I>len</I> bytes from <I>src</I> to <I>dest</I>.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="mem.html#memmove">memmove</A></B><DD>Copies a block of <I>len</I> bytes from <I>src</I> to <I>dest</I>, with possibility
of overlaping of source and destination block.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="mem.html#memset">memset</A></B><DD>Sets <I>num</I> bytes of <I>buffer</I> to byte <I>c</I>.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="mem.html#memucmp">memucmp</A></B><DD>Compares two blocks of unsigned chars.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="stdio.html#sprintf">sprintf</A></B><DD>Sends formatted output to a string.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#strcat">strcat</A></B><DD>Appends <I>src</I> to <I>dest</I>.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#strchr">strchr</A></B><DD>Finds <I>c</I> in <I>str</I>.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#strcmp">strcmp</A></B><DD>Compares one string to another.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#strcpy">strcpy</A></B><DD>Copies string <I>src</I> to <I>dest</I>.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#strcspn">strcspn</A></B><DD>Scans a string.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#strerror">strerror</A></B><DD>Gives an error message string.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#stricmp">stricmp</A></B><DD>Performs case-insensitive string comparison.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#strlen">strlen</A></B><DD>Calculates length of a string.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#strncat">strncat</A></B><DD>Appends at most <I>maxlen</I> characters of <I>src</I> to <I>dest</I>.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#strncmp">strncmp</A></B><DD>Compares at most maxlen characters of one string to another.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#strncpy">strncpy</A></B><DD>Copies at most <I>maxlen</I> characters of <I>src</I> to <I>dest</I>.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#strpbrk">strpbrk</A></B><DD>Scans one string for the first occurrence of any character that's in a second
string.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#strrchr">strrchr</A></B><DD>Finds the last occurrence of <I>c</I> in <I>str</I>.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#strspn">strspn</A></B><DD>Scans a string for a segment that is a subset of a set of characters.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#strstr">strstr</A></B><DD>Finds the first occurrence of a substring in another string.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#strtok">strtok</A></B><DD>Scans <I>s1</I> for the first token not contained in <I>s2</I>.</DL>
<H3><U>Constants</U></H3>
<DL INDENT="20"><DT><B><A HREF="alloc.html#NULL">NULL</A></B><DD>A null-pointer value.</DL>
<H3><U>Predefined Types</U></H3>
<DL INDENT="20"><DT><B><A HREF="stddef.html#size_t">size_t</A></B><DD>A type to define sizes of strings and memory blocks.</DL>
<HR>
<H3><A NAME="CharNumber"><U>CharNumber</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#int">char</A></B> CharNumber (<B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#int">char</A></B> num, <B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#int">char</A></B> pos, <B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#int">char</A></B> *string);</TD></TR></TABLE></P>
<P><B>Writes an unsigned char in base 10 at given offset from the beginning of a string, and 
null-terminates the string.</B></P>

<P>CharNumber writes number <I>num</I> as a string, in base 10, at <CODE>string[pos]</CODE>, and 
null-terminates string after the number has been printed.<BR>
It returns the offset of the terminating null character from the beginning of <I>string</I>.<BR>
Of course, CharNumber may be useful only if the number you want to write is in the range of 
values an unsigned char can represent.</P>

<HR>
<H3><A NAME="cmpstri"><U>cmpstri</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> cmpstri (<B><A HREF="keywords.html#const">const</A></B> <B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#int">char</A></B> *s1, <B><A HREF="keywords.html#const">const</A></B> <B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#int">char</A></B> *s2);</TD></TR></TABLE></P>
<P><B>Performs case-insensitive string comparison.</B></P>

<P>cmpstri acts like <A HREF="#strcmp">strcmp</A>, but the comparison is
case-insensitive. More precisely, it internally converts all uppercase
characters to lowercase (unlike <A HREF="#stricmp">stricmp</A>, which
converts all lowercase characters to uppercase).</P>

<P>See also: <A HREF="#stricmp">stricmp</A>, <A HREF="#strcmp">strcmp</A></P>
<HR>
<H3><A NAME="FirstNonblank"><U>FirstNonblank</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.00 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#int">char</A></B> *FirstNonblank (<B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#int">char</A></B> *s);</TD></TR></TABLE></P>
<P><B>Returns a pointer to the first nonblank character in given string.</B></P>

<P>This function is very limited: it simply searches the string <I>s</I> for blank characters 
(space, code 0x20), and returns when it finds a character different from 0x20.</P>

<HR>
<H3><A NAME="strcat"><U>strcat</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#int">char</A></B> *strcat (<B><A HREF="keywords.html#int">char</A></B> *dest, <B><A HREF="keywords.html#const">const</A></B> <B><A HREF="keywords.html#int">char</A></B> *src);</TD></TR></TABLE></P>
<P><B>Appends <I>src</I> to <I>dest</I>.</B></P>

<P>strcat appends a copy of <I>src</I> to the end of <I>dest</I>, overwriting
the null character terminating the string pointed to by <I>dest</I>.
The length of the resulting
string is <CODE>strlen(<I>dest</I>) + strlen(<I>src</I>)</CODE>. strcat returns a pointer to the
concatenated strings (this is <I>dest</I>, in fact).
<BR><BR>
<B>Note:</B> This routine assumes that <I>dest</I>
points to a buffer large enough to hold the concatenated string.</P>

<HR>
<H3><A NAME="strchr"><U>strchr</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#int">char</A></B> *strchr (<B><A HREF="keywords.html#const">const</A></B> <B><A HREF="keywords.html#int">char</A></B> *str, <B><A HREF="keywords.html#short">short</A></B> c);</TD></TR></TABLE></P>
<P><B>Finds <I>c</I> in <I>str</I>.</B></P>

<P>strchr scans a string in the forward direction, looking for a specific
character. strchr finds the first occurrence of the character <I>c</I> in the string
<I>str</I>. The null-terminator is considered to be part of the string, so that, for
example,</P>
<PRE>strchr (s, 0)
</PRE>
<P>returns a pointer to the terminating null character of the string <I>s</I>.
Returns a pointer to the first occurrence of the character <I>c</I> in <I>str</I>.
If <I>c</I> does not occur in <I>str</I>, strchr returns <A HREF="alloc.html#NULL">NULL</A>.</P>

<HR>
<H3><A NAME="strcmp"><U>strcmp</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> strcmp (<B><A HREF="keywords.html#const">const</A></B> <B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#int">char</A></B> *s1, <B><A HREF="keywords.html#const">const</A></B> <B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#int">char</A></B> *s2);</TD></TR></TABLE></P>
<P><B>Compares one string to another.</B></P>

<P>strcmp performs an unsigned comparison of <I>s1</I> to <I>s2</I>. It starts with the first
character in each string and continues with subsequent characters until the
corresponding characters differ or until the end of the strings is reached.
strcmp returns a value that is</P>
<UL>
<LI><P>&lt; 0 if <I>s1</I> is less than <I>s2</I></P></LI>
<LI><P>== 0 if <I>s1</I> is the same as <I>s2</I></P></LI>
<LI><P>&gt; 0 if <I>s1</I> is greater than <I>s2</I></P></LI>
</UL>
<P>More precisely, if the strings differ, the value of the first nonmatching character in <I>s2</I>
subtracted from the corresponding character in <I>s1</I> is returned.
<BR><BR>
<B>Note:</B> This routine is declared as "short" although the ANSI standard proposes "long". This is important,
because TIOS the strncmp routine puts garbage in the higher half of the d0 register.</P>

<P>See also: <A HREF="#strncmp">strncmp</A>, <A HREF="#cmpstri">cmpstri</A>, <A HREF="#stricmp">stricmp</A></P>
<HR>
<H3><A NAME="strcpy"><U>strcpy</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#int">char</A></B> *strcpy (<B><A HREF="keywords.html#int">char</A></B> *dest, <B><A HREF="keywords.html#const">const</A></B> <B><A HREF="keywords.html#int">char</A></B> *src);</TD></TR></TABLE></P>
<P><B>Copies string <I>src</I> to <I>dest</I>.</B></P>

<P>strcpy copies string <I>src</I> to <I>dest</I>, stopping after the terminating null
character has been moved. Returns <I>dest</I>.
<BR><BR>
<B>Note:</B> If the objects pointed to by <I>src</I> and <I>dest</I> overlap in memory, the
behavior is undefined. strcpy assumes that <I>src</I> points to a buffer large enough to
hold <I>dest</I>.</P>

<HR>
<H3><A NAME="strcspn"><U>strcspn</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#short">long</A></B> strcspn (<B><A HREF="keywords.html#const">const</A></B> <B><A HREF="keywords.html#int">char</A></B> *s1, <B><A HREF="keywords.html#const">const</A></B> <B><A HREF="keywords.html#int">char</A></B> *s2);</TD></TR></TABLE></P>
<P><B>Scans a string.</B></P>

<P>strcspn returns the length of the initial segment of string <I>s1</I> that consists
entirely of characters not from string <I>s2</I>. If string <I>s1</I> contains no
characters from string <I>s2</I>, strcspn returns the length of string <I>s1</I>.</P>

<HR>
<H3><A NAME="strerror"><U>strerror</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#int">char</A></B> *strerror (<B><A HREF="keywords.html#short">short</A></B> err_no);</TD></TR></TABLE></P>
<P><B>Gives an error message string.</B></P>

<P>strerror returns a pointer to string which contains text of the system error message
<I>err_no</I>. Note that this is not a TI-Basic error message, but a low level
error message. Here is a complete table of such messages:
<BR><BR>
<TABLE CLASS="NOBORDER">
<TR><TD VALIGN="TOP" WIDTH="50">0</TD><TD>no error</TD></TR>
<TR><TD VALIGN="TOP">1</TD><TD>no such file entry</TD></TR>
<TR><TD VALIGN="TOP">2</TD><TD>I/O error</TD></TR>
<TR><TD VALIGN="TOP">3</TD><TD>not a serial device</TD></TR>
<TR><TD VALIGN="TOP">4</TD><TD>out of memory</TD></TR>
<TR><TD VALIGN="TOP">5</TD><TD>permission denied</TD></TR>
<TR><TD VALIGN="TOP">6</TD><TD>block device required</TD></TR>
<TR><TD VALIGN="TOP">7</TD><TD>no such device</TD></TR>
<TR><TD VALIGN="TOP">8</TD><TD>invalid argument</TD></TR>
<TR><TD VALIGN="TOP">9</TD><TD>file table is full</TD></TR>
<TR><TD VALIGN="TOP">10</TD><TD>device directory is full</TD></TR>
<TR><TD VALIGN="TOP">11</TD><TD>no space left on device</TD></TR>
<TR><TD VALIGN="TOP">12</TD><TD>no more allocation blocks</TD></TR>
<TR><TD VALIGN="TOP">13</TD><TD>no more data blocks on device</TD></TR>
<TR><TD VALIGN="TOP">14</TD><TD>file is open</TD></TR>
<TR><TD VALIGN="TOP">15</TD><TD>no RAM space configured</TD></TR>
<TR><TD VALIGN="TOP">16</TD><TD>no heap space configured</TD></TR>
<TR><TD VALIGN="TOP">17</TD><TD>seek can't extend read only file</TD></TR>
<TR><TD VALIGN="TOP">18</TD><TD>bad file descriptor - file not open</TD></TR>
<TR><TD VALIGN="TOP">19</TD><TD>invalid signal number</TD></TR>
<TR><TD VALIGN="TOP">20</TD><TD>argument out of range</TD></TR>
<TR><TD VALIGN="TOP">21</TD><TD>result out of range</TD></TR>
</TABLE>
<BR>
Other values of <I>err_no</I> will generate "undefined errno value" message.
<BR><BR>
<B>Note:</B> antediluvian releases of TIGCCLIB report wrongly that <I>err_no</I>
is a TI-Basic error code, which is not true. To get a pointer to TI-Basic error
message, use <A HREF="error.html#find_error_message">find_error_message</A> function.</P>

<HR>
<H3><A NAME="stricmp"><U>stricmp</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.00 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> stricmp (<B><A HREF="keywords.html#const">const</A></B> <B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#int">char</A></B> *s1, <B><A HREF="keywords.html#const">const</A></B> <B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#int">char</A></B> *s2);</TD></TR></TABLE></P>
<P><B>Performs case-insensitive string comparison.</B></P>

<P>stricmp acts like <A HREF="#strcmp">strcmp</A>, but the comparison is
case-insensitive. More precisely, it internally converts all lowercase
characters to uppercase (unlike <A HREF="#cmpstri">cmpstri</A>, which
converts all uppercase characters to lowercase).
<BR><BR>
<B>Note:</B> This function is buggy in the AMS versions 2.00 through 2.03: If
<I>s1</I> contains characters above 127 (i.e. extended/international
characters), and these characters are really needed for the comparison, it
always returns a negative value. So, if you really need to use this function,
make sure that you never call it with such characters in <I>s1</I>.</P>

<P>See also: <A HREF="#cmpstri">cmpstri</A>, <A HREF="#strcmp">strcmp</A></P>
<HR>
<H3><A NAME="strlen"><U>strlen</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#short">long</A></B> strlen (<B><A HREF="keywords.html#const">const</A></B> <B><A HREF="keywords.html#int">char</A></B> *str);</TD></TR></TABLE></P>
<P><B>Calculates length of a string.</B></P>

<P>strlen calculates the length of <I>str</I>. Returns the number of characters in <I>str</I>,
not counting the terminating null character.</P>

<HR>
<H3><A NAME="strncat"><U>strncat</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#int">char</A></B> *strncat (<B><A HREF="keywords.html#int">char</A></B> *dest, <B><A HREF="keywords.html#const">const</A></B> <B><A HREF="keywords.html#int">char</A></B> *src, <B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#short">long</A></B> maxlen);</TD></TR></TABLE></P>
<P><B>Appends at most <I>maxlen</I> characters of <I>src</I> to <I>dest</I>.</B></P>

<P>strncat copies at most <I>maxlen</I> characters of <I>src</I> to the end of <I>dest</I> and then
appends a null character. The null character terminating <I>src</I> is
overwritten by the first character in <I>dest</I>. The maximum length of the resulting string is
strlen(<I>dest</I>) + <I>maxlen</I>. strncat returns <I>dest</I>.
<BR><BR>
<B>Note:</B> This routine assumes that <I>src</I>
points to a buffer large enough to hold the concatenated string.
Since strncat appends a null character to the result, it may add <I>maxlen</I>+1
characters to the string.</P>

<HR>
<H3><A NAME="strncmp"><U>strncmp</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> strncmp (<B><A HREF="keywords.html#const">const</A></B> <B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#int">char</A></B> *s1, <B><A HREF="keywords.html#const">const</A></B> <B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#int">char</A></B> *s2, <B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#short">long</A></B> maxlen);</TD></TR></TABLE></P>
<P><B>Compares at most maxlen characters of one string to another.</B></P>

<P>strncmp makes the same unsigned comparison as <A HREF="#strcmp">strcmp</A>, but looks at no more
than <I>maxlen</I> characters. It starts with the first character in each string and
continues with subsequent characters until the corresponding characters
differ or until it has examined <I>maxlen</I> characters. strncmp returns an int
value based on the result of comparing <I>s1</I> (or part of it) to <I>s2</I> (or part of
it):</P>
<UL>
<LI><P>&lt; 0 if <I>s1</I> is less than <I>s2</I></P></LI>
<LI><P>== 0 if <I>s1</I> is the same as <I>s2</I></P></LI>
<LI><P>&gt; 0 if <I>s1</I> is greater than <I>s2</I></P></LI>
</UL>
<P>More precisely, if the strings differ, the value of the first nonmatching character in <I>s2</I>
subtracted from the corresponding character in <I>s1</I> is returned. The
subtraction casts the input strings to unsigned chars so that the characters
in the range 128..255 are considered above the characters in the range 0..127.
<BR><BR>
<B>Note:</B> This routine is declared as "short" although the ANSI standard proposes "long". This is important,
because TIOS the strncmp routine puts garbage in the higher half of the d0 register.</P>

<P>See also: <A HREF="#strcmp">strcmp</A></P>
<HR>
<H3><A NAME="strncpy"><U>strncpy</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#int">char</A></B> *strncpy (<B><A HREF="keywords.html#int">char</A></B> *dest, <B><A HREF="keywords.html#const">const</A></B> <B><A HREF="keywords.html#int">char</A></B> *src, <B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#short">long</A></B> maxlen);</TD></TR></TABLE></P>
<P><B>Copies at most <I>maxlen</I> characters of <I>src</I> to <I>dest</I>.</B></P>

<P>strncpy copies up to <I>maxlen</I> characters from <I>src</I> into <I>dest</I>, truncating or
null-padding <I>dest</I>. The target string, <I>dest</I>, might not be null-terminated if
the length of <I>src</I> is <I>maxlen</I> or more. Returns <I>dest</I>.
<BR><BR>
<B>Note:</B> If the objects pointed to by <I>src</I> and <I>dest</I> overlap in memory, the
behavior is undefined. strcpy assumes that <I>src</I> points to a buffer large enough to
hold <I>maxlen</I> characters.</P>

<HR>
<H3><A NAME="strpbrk"><U>strpbrk</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#int">char</A></B> *strpbrk (<B><A HREF="keywords.html#const">const</A></B> <B><A HREF="keywords.html#int">char</A></B> *s1, <B><A HREF="keywords.html#const">const</A></B> <B><A HREF="keywords.html#int">char</A></B> *s2);</TD></TR></TABLE></P>
<P><B>Scans one string for the first occurrence of any character that's in a second
string.</B></P>

<P>strpbrk scans a string, <I>s1</I>, for the first occurrence of any character
appearing in <I>s2</I>. strpbrk returns a pointer to the first occurrence of any of
the characters in <I>s2</I>. If none of the <I>s2</I> characters occurs in <I>s1</I>,
it returns <A HREF="alloc.html#NULL">NULL</A>.</P>

<HR>
<H3><A NAME="strrchr"><U>strrchr</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#int">char</A></B> *strrchr (<B><A HREF="keywords.html#const">const</A></B> <B><A HREF="keywords.html#int">char</A></B> *str, <B><A HREF="keywords.html#short">short</A></B> c);</TD></TR></TABLE></P>
<P><B>Finds the last occurrence of <I>c</I> in <I>str</I>.</B></P>

<P>strrchr scans a string in the reverse direction, looking for a specific
character. strrchr finds the last occurrence of the character <I>c</I> in the string
<I>str</I>. The null-terminator is considered to be part of the string. strrchr
returns a pointer to the last occurrence of the character <I>c</I>. If <I>c</I> does not
occur in <I>str</I>, strrchr returns <A HREF="alloc.html#NULL">NULL</A>.</P>

<HR>
<H3><A NAME="strspn"><U>strspn</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#short">long</A></B> strspn (<B><A HREF="keywords.html#const">const</A></B> <B><A HREF="keywords.html#int">char</A></B> *s1, <B><A HREF="keywords.html#const">const</A></B> <B><A HREF="keywords.html#int">char</A></B> *s2);</TD></TR></TABLE></P>
<P><B>Scans a string for a segment that is a subset of a set of characters.</B></P>

<P>strspn finds the initial segment of string <I>s1</I> that consists entirely of
characters from string <I>s2</I>. Returns the length of the initial segment of <I>s1</I>
that consists of characters entirely from <I>s2</I>. If <I>s1</I> contains no characters from <I>s2</I>,
<A HREF="alloc.html#NULL">NULL</A> is returned.</P>

<HR>
<H3><A NAME="strstr"><U>strstr</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#int">char</A></B> *strstr (<B><A HREF="keywords.html#const">const</A></B> <B><A HREF="keywords.html#int">char</A></B> *str, <B><A HREF="keywords.html#const">const</A></B> <B><A HREF="keywords.html#int">char</A></B> *substr);</TD></TR></TABLE></P>
<P><B>Finds the first occurrence of a substring in another string.</B></P>

<P>strstr scans <I>str</I> for the first occurrence of the substring <I>substr</I>. strstr returns a
pointer to the element in <I>str</I> where <I>substr</I> begins (points to <I>substr</I> in <I>str</I>).
If <I>substr</I> does not occur in <I>str</I>, strstr returns <A HREF="alloc.html#NULL">NULL</A>.</P>

<HR>
<H3><A NAME="strtok"><U>strtok</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#int">char</A></B> *strtok (<B><A HREF="keywords.html#int">char</A></B> *s1, <B><A HREF="keywords.html#const">const</A></B> <B><A HREF="keywords.html#int">char</A></B> *s2);</TD></TR></TABLE></P>
<P><B>Scans <I>s1</I> for the first token not contained in <I>s2</I>.</B></P>

<P>strtok considers the string s1 to consist of a sequence of zero or more text
tokens, separated by spans of one or more characters from the separator string
<I>s2</I>. The first call to strtok returns a pointer to the first character of the
first token in <I>s1</I> and writes a null character into <I>s1</I> immediately following
the returned token. Subsequent calls with <A HREF="alloc.html#NULL">NULL</A> for the first argument will
work through the string <I>s1</I> in this way, until no tokens remain. The separator
string, <I>s2</I>, can be different from call to call. strtok returns a pointer to
the token found in <I>s1</I>. A null pointer is returned when there are no more
tokens.</P>

<HR>
<H3><A HREF="index.html">Return to the main index</A></H3>
</BODY>
</HTML>
